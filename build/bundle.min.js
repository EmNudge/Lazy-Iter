"use strict";class t{constructor(t){if(this.arr=[],this.funcs=[],"number"!=typeof t){if(!t.length)throw new Error("Lazy iterable cannot contain an empty array");this.arr=t}else{const r=Array(t).fill(null);this.arr=r}}map(t){return this.funcs.push({type:"map",func:t}),this}filter(t){return this.funcs.push({type:"filter",func:t}),this}takeWhile(t){return this.funcs.push({type:"take_while",func:t}),this}take(t){return this.funcs.push({type:"take_while",func:(r,e)=>e<t}),this}clone(){const r=new t(this.arr);for(const{type:t,func:e}of this.funcs)r.funcs.push({type:t,func:e});return r}forEach(t){for(const r of this)t(r)}find(t){let r=0;for(const e of this){if(t(e,r))return e;r++}return null}reduce(t,r){let e=r||null,s=0;for(const r of this)s||e||(e=r),e=t(e,r,s),s++;return e}collect(){return[...this]}*[Symbol.iterator](){let t=0;t:for(const r of this.arr){let e=r;for(const{type:r,func:s}of this.funcs)if("map"!==r){if("filter"!==r){if(!s(e,t))break t}else if(!s(e,t))continue t}else e=s(e,t);yield e,t++}}}module.exports=t;
